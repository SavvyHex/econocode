// Simple arithmetic grammar with types
use crate::ast::{Expr, Type};
use crate::lexer::Token;

grammar;

extern {
    type Location = usize;
    type Error = ();

    enum Token {
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "(" => Token::LParen,
        ")" => Token::RParen,
        ":" => Token::Colon,
        "i32" => Token::I32,
        "i64" => Token::I64,
        "int" => Token::Int(<i64>),
        "ident" => Token::Ident(<String>),
    }
}

pub Expr: Expr = {
    <l:Expr> "+" <r:Term> => Expr::Add(Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Term> => Expr::Sub(Box::new(l), Box::new(r)),
    Term,
};

Term: Expr = {
    <l:Term> "*" <r:Factor> => Expr::Mul(Box::new(l), Box::new(r)),
    <l:Term> "/" <r:Factor> => Expr::Div(Box::new(l), Box::new(r)),
    Factor,
};

Factor: Expr = {
    <n:"int"> <t:Type> => Expr::Int(n, t),
    <n:"int"> => Expr::Int(n, Type::I64), // default to i64
    <id:"ident"> ":" <t:Type> => Expr::Var(id, t),
    <id:"ident"> => Expr::Var(id, Type::I64), // default to i64
    "(" <e:Expr> ")" => e,
};

Type: Type = {
    "i32" => Type::I32,
    "i64" => Type::I64,
};
